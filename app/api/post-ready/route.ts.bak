import { NextRequest, NextResponse } from 'next/server';
import { getAllTweets, saveTweet } from '@/lib/neon-db';
import { postToTwitter } from '@/lib/twitter';
import { logET } from '@/lib/timezone';

export async function GET(request: NextRequest) {
  try {
    // Verify authorization
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const serverUTC = new Date();
    const now = new Date(serverUTC.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    logET(`üîç Checking for tweets ready to post at ${now.getHours()}:${now.getMinutes().toString().padStart(2, '0')} IST`);

    // Get all tweets
    const allTweets = await getAllTweets();
    
    // Find tweets ready to post (scheduled within 15-minute window)
    const readyTweets = allTweets.filter(tweet => {
      if (tweet.status !== 'scheduled' || !tweet.scheduled_for) return false;
      
      const scheduledUTC = new Date(tweet.scheduled_for);
      const scheduledTime = new Date(scheduledUTC.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
      const scheduledMinutes = scheduledTime.getHours() * 60 + scheduledTime.getMinutes();
      
      // Check if tweet is scheduled for within ¬±7 minutes of current time
      const timeDiff = Math.abs(currentTime - scheduledMinutes);
      return timeDiff <= 7; // 15-minute window (¬±7 minutes)
    });

    logET(`üìù Found ${readyTweets.length} tweets ready to post`);

    let postedCount = 0;
    const errors: string[] = [];

    // Post each ready tweet
    for (const tweet of readyTweets) {
      try {
        logET(`üì§ Posting tweet: ${tweet.content.substring(0, 50)}...`);
        
        const result = await postToTwitter(tweet.content, tweet.hashtags);
        
        // Update tweet status
        const updatedTweet = {
          ...tweet,
          status: 'posted' as const,
          postedAt: new Date().toISOString(),
          twitterId: result.data.id,
          twitterUrl: `https://x.com/user/status/${result.data.id}`
        };
        
        await saveTweet(updatedTweet);
        postedCount++;
        
        logET(`‚úÖ Successfully posted tweet ${tweet.id} - Twitter ID: ${result.data.id}`);
        
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        logET(`‚ùå Failed to post tweet ${tweet.id}: ${errorMsg}`);
        
        // Mark tweet as failed
        const failedTweet = {
          ...tweet,
          status: 'failed' as const,
          errorMessage: errorMsg
        };
        await saveTweet(failedTweet);
        
        errors.push(`Tweet ${tweet.id}: ${errorMsg}`);
      }
    }

    const response = {
      success: true,
      timestamp: serverUTC.toISOString(),
      currentTime: `${now.getHours()}:${now.getMinutes().toString().padStart(2, '0')} IST`,
      found: readyTweets.length,
      posted: postedCount,
      errors: errors.length,
      errorDetails: errors,
      message: postedCount > 0 
        ? `üöÄ Posted ${postedCount} tweets successfully!`
        : '‚è≥ No tweets ready to post at this time',
    };

    logET(`üìä Posting summary: ${postedCount}/${readyTweets.length} posted, ${errors.length} errors`);
    
    return NextResponse.json(response);

  } catch (error) {
    logET('‚ùå Post-ready check failed:', error instanceof Error ? error.message : String(error));
    
    return NextResponse.json({
      success: false,
      error: 'Failed to check/post ready tweets',
      details: error instanceof Error ? error.message : String(error),
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}