import { generateTweet, TweetGenerationOptions } from './openai';
import { calculateQualityScore } from './quality-scorer';
import { saveTweet, generateTweetId } from './db';

export interface AutoGeneratedTweet {
  id: string;
  content: string;
  hashtags: string[];
  persona: string;
  qualityScore: {
    overall: number;
    metrics: {
      engagement: number;
      readability: number;
      uniqueness: number;
      personaAlignment: number;
      viralPotential: number;
      trendRelevance: number;
    };
    grade: 'A' | 'B' | 'C' | 'D' | 'F';
    feedback: string[];
  };
  createdAt: Date;
  status: 'draft';
}

export interface AutoGenerationOptions {
  count: number;
  minQualityScore?: number;
  maxAttempts?: number;
}

const PERSONAS = ['unhinged_satirist', 'desi_philosopher'] as const;

const GENERATION_VARIATIONS = [
  { includeHashtags: true, useTrendingTopics: true },
  { includeHashtags: false, useTrendingTopics: true },
  { includeHashtags: true, useTrendingTopics: false },
  { includeHashtags: false, useTrendingTopics: false },
];

export async function generateHighQualityTweets(options: AutoGenerationOptions): Promise<AutoGeneratedTweet[]> {
  const { count, minQualityScore = 75, maxAttempts = count * 3 } = options;
  const tweets: AutoGeneratedTweet[] = [];
  let attempts = 0;

  console.log(`ü§ñ Starting auto-generation: target ${count} tweets, min quality ${minQualityScore}`);

  while (tweets.length < count && attempts < maxAttempts) {
    attempts++;
    
    try {
      // Randomize persona and generation settings
      const persona = PERSONAS[Math.floor(Math.random() * PERSONAS.length)];
      const variation = GENERATION_VARIATIONS[Math.floor(Math.random() * GENERATION_VARIATIONS.length)];
      
      const generationOptions: TweetGenerationOptions = {
        persona,
        ...variation,
      };

      console.log(`üìù Attempt ${attempts}: Generating with ${persona}, hashtags: ${variation.includeHashtags}, trending: ${variation.useTrendingTopics}`);

      const generatedTweet = await generateTweet(generationOptions);
      const qualityScore = calculateQualityScore(generatedTweet.content, generatedTweet.hashtags, persona);

      if (qualityScore.overall >= minQualityScore) {
        const tweet: AutoGeneratedTweet = {
          id: generateTweetId(),
          content: generatedTweet.content,
          hashtags: generatedTweet.hashtags,
          persona,
          qualityScore,
          createdAt: new Date(),
          status: 'draft',
        };

        tweets.push(tweet);
        console.log(`‚úÖ Quality tweet generated (${qualityScore.overall}/100, Grade: ${qualityScore.grade})`);
      } else {
        console.log(`‚ùå Low quality tweet rejected (${qualityScore.overall}/100, Grade: ${qualityScore.grade})`);
      }

      // Add delay between generations to avoid rate limits
      if (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }

    } catch (error) {
      console.error(`‚ùå Generation attempt ${attempts} failed:`, error);
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
  }

  console.log(`üéØ Auto-generation complete: ${tweets.length}/${count} high-quality tweets generated in ${attempts} attempts`);
  return tweets;
}

export async function selectBestTweetsForPosting(tweets: AutoGeneratedTweet[], targetCount: number = 2): Promise<AutoGeneratedTweet[]> {
  if (tweets.length === 0) return [];

  // Sort by quality score (descending)
  const sortedTweets = [...tweets].sort((a, b) => b.qualityScore.overall - a.qualityScore.overall);

  // Select the best tweets
  const selectedTweets = sortedTweets.slice(0, targetCount);

  console.log(`üèÜ Selected ${selectedTweets.length} best tweets for posting:`);
  selectedTweets.forEach((tweet, index) => {
    console.log(`  ${index + 1}. Quality: ${tweet.qualityScore.overall}/100 (${tweet.qualityScore.grade}) - ${tweet.content.substring(0, 50)}...`);
  });

  return selectedTweets;
}

export async function saveGeneratedTweets(tweets: AutoGeneratedTweet[]): Promise<void> {
  for (const tweet of tweets) {
    await saveTweet(tweet);
  }
  console.log(`üíæ Saved ${tweets.length} tweets to database`);
}